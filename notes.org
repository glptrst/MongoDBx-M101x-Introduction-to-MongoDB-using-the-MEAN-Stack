#+TITLE: Introduction to MongoDB using the MEAN Stack

* Introduction to MongoDB and NodeJS
** Starting a standalone mongod and connecting with shell
    Install mongodb (I shall use dnf on Fedora).
    
    Create the dir ~/data/db
    
    Start mongod with:
    $ mongod --dbpath ~/data/db
    
    In another shell you can start the mongo shell you allows you to
    do basic experimentation with MongoDB:
    $ mongo

    MongoDB stores object as BSON, which is a strict superset of JSON.
    
    Insert a single document with just one key, hello, and one value, world:
    > db.test.insert({ hello: "world"});

    MongoDB stores document in separate collections. Each collection
    belongs to a database, and collection names are unique within a
    single database. Typing db you can see the current database.  In
    this case we have told MongoDB to insert the document in the
    collection named 'test'.
    
    Then we can query it back:
    > db.test.findOne({ hello: "world"});

    In this case we have told MongoDB to search for document in the
    collection named 'test'.

*** quiz
     In order to find all documents in the 'movies' collection for
     which the 'leadActor' key equals "Arnold Schwarzenegger", which
     of the following commands would you execute in the mongo shell?
     
     1) db.exec('SELECT * FROM movies WHERE leadActor="Arnold
        Schwarzenegger"')

     2) db.movies.find({ leadActor: 'Arnold Schwarzenegger' })

     3) db.movies.insert({ leadActor: 'Arnold Schwarzenegger' })

     4) db.sample.find({ leadActor: 'Arnold Schwarzenegger' })

	
     Answer: 2.
** package.json: installing dependencies with npm
    Install NodeJS. NodeJS comes with npm included.

    With 
    $ node -v
    and 
    $ npm -v 
    you can check the versions.
    
    When starting a new NodeJS application, the first thing you want
    to do is create a package dot json file.  Package dot json describes
    your app's meta data, including its name, the version, the author, and
    any the npm packages that it depends on.

    For this course, you will primarily be concerned with package dot
    json as a way to declare which packages your app depends on.
    
    Let's create a package dot json that depends on Underscore.
    Create a file name 'package.json' with this content:
    {
      "dependencies": {
        "underscore" "1.5.2"
      }
    }
    
    To install the dependencies, run:
    $ npm install

    You should see now a node_modules directory in your current
    working directory. If you look in the node_modules directory you
    should see a directory named underscore. This is where the
    underscore package lives.

    You can now write a simple NodeJS program called 'index.js' that
    includes underscore, suing NodeJS' built-in require function
    (Underscore has a simple .each function that executes a function
    for every element in an array):

#+BEGIN_SRC javascript

    var _ = require('underscore');

    _.each([1,2,3], function(v){
      console.log(v);
    });

#+END_SRC
    
    You can now run the program with:
    $ node index.js

    Note that each NodeJS project has its own node underscore modules
    directory where npm installs packages.

    In general it is a good choice to not track node modules with source
    control (unless you really know what you are doing).
*** quiz
     The npm install command downloads npm modules into which
     directory?
     
     1) /usr/local/nodepath
       
     2) /etc/node

     3) ./node_modules

     4) ./.npm

	
     Answer: 1.
	 
** Connecting to mongodb with NodeJS
   The MongoDB NPM package is the officially supported MongoDB node.js
   driver.  The driver lets you write node.js code to talk to MongoDB.
   In this course you'll primarily use Mongoose to interface with
   MongoDB. Mongoose is an object document mapper, or ODM for short,
   that provides functionality like schema validation on top of the
   MongoDB node.js driver. However, since Mongoose is a layer on top
   of the MongoDB driver, and uses the driver to talk to the MongoDB
   server MongoD, it helps to start with a low level driver before
   using the high level tools.

   Let's write our first MongoDB query in node.js.
   
   The first step is to add a dependency on MongoDB version
   2.0.35 to your package.json.

   {
     "dependencies": {
       "mongodb": "2.0.35"
     }
   }

   (We could have written "~2.0" to get the latest 2.0 release)

   Now that you've added the MongoDB driver to your package.json,
   you're ready to run your first query from node.js. 

   'index.js':

#+BEGIN_SRC javascript

      var mongodb = require('mongodb');
       
      var uri = 'mongodb://localhost:27017/example';

      /*
      This MongoClient helper is what you will use to create a connection
      to MongoDB. This MongoClient.connect function takes a MongoDB
      connection string, which is a URI that tells the driver which MongoD
      to connect to. And in this case the URI is MongoDB://localhost port
      27017, and the example database. In other words, this translates to
      connect to the MongoDB running on localhost port 27017, and use the
      example database. The MongoClient.connect function also takes a
      callback function. The callback function gets called when either an
      error occurred, or the driver successfully connected. The callback
      function takes two parameters. A potentially null error and a
      potentially null db handle. In this simple example, if an error
      occurs, we just log it and exit.
      */
      mongodb.MongoClient.connect(uri, function(error, db) {
         if (error) {
           console.log(error);
           process.exit(1);
         }
         /*
         Once the program has a db handle, it can then access the sample
         collection using the db.collection collection function. With a
         collection you can use the insert function to insert a document much
         like how you did in the shell.
         */     
         db.collection('sample').insert({ x: 1 }, function(error, result) {
           if (error) {
             console.log(error);
             process.exit(1);
           }
           /*
           Query for a document is slightly trickier. If you pass the call back
           to the driver's find function, you'll get back a cursor rather than a
           set of documents. In the context of MongoDB, a cursor is an object
           that you could call next on to get the next document. However, in
           order to make things easier for users who don't need fine grained
           control over the cursor, the driver has this nice chainable toArray
           function that exhausts the cursor for you and returns an array of
           documents in the call back. And once you run this program, you should
           see that MongoDB successfully inserted a document, and then query to
           back.
           */
           db.collection('sample').find().toArray(function(error, docs) {
             if (error) {
               console.log(error);
               process.exit(1);
             }
       
             console.log('Found docs:');
             docs.forEach(function(doc) {
               console.log(JSON.stringify(doc));
             });
             process.exit(0);
           });
         });
       });

#+END_SRC
*** quiz
    Consider the following nodejs code:

    #+BEGIN_QUOTE javascript
    db.collection('sample').find(function(error, x) {
    });
    #+END_QUOTE
    
    Assuming that the find succeeds, the x variable is a(n):

    1) array of documents

    2) cursor

    3) binary heap

       
    Answer: 2.
** Inserts and queries using the node.js driver
   As you saw in the 'connecting to MongoDB with Node.js' lesson, the
   Node.js MongoDB driver enables you to store JSON documents in
   MongoDB and query for these objects. For the purposes of this
   course, you should think of MongoDB as something that stores
   arbitrary JavaScript objects and enables you to run queries to find
   JavaScript objects that match a certain criteria. Again, in this
   course, such objects will be called JSON documents.

   With that in mind, let's take a closer look at how you can use the
   MongoDB Node.js driver to write documents to MongoDB, and also how
   to query MongoDB to retrieve documents your application requires.

   'crud-example.js':

   #+BEGIN_SRC javascript
     var mongodb = require('mongodb');

     var uri = 'mongodb://localhost:27017/example';
     /*
     Again, the first thing this program does is connect to MongoDB using
     this connect function. You pass the connection function a connection
     string and a callback function. For now all you need to know is
     callbacks are functions you provide to the Node.js driver to specify
     what to do once a given operation completes. Once, again the .connect
     function does not return a handle to a MongoDB connection. Instead,
     you need to pass a callback function that the MongoDB driver executes
     when your MongoDB handle is ready. The callback takes two parameters:
     an error and a db handle. If the operation fails, the callback gets an
     error as the first argument. If the operation succeeds, the callback
     gets null as the first argument and the result of the operation as the
     second argument.
     ,*/
     mongodb.MongoClient.connect(uri, function(){
       /*
       In the case of this code, if the callback gets an error, that means
       that the driver cannot connect to MongoDB.
       ,*/
       if (error) {
         console.log(error);
         process.exit(1);
       }

       /*
       Now, if error is null, that means there was no error and you now
       have a db handle that you can use to interact with MongoDB.  So with
       this db handle, you can now insert a JSON object into a MongoDB
       collection.
       ,*/
       var doc = {
         title: 'Jaws',
         year: 1975,
         director: 'Steven Spielberg',
         rating: 'PG'
       }
       /*
       So this code right here inserts a document representing the movie
       entitled Jaws into the collection named movies. This .collection
       function gives you a handle to an individual MongoDB
       collection. Note that in order to identify the collection that you
       need, you specify it by name with a string argument to this
       .collection function. Now, with this .insert call, you also need to
       pass a callback.  This callback will get called when the insert
       operation completes and will report any errors that occurred in
       inserting the document.
       ,*/
       db.collection('movies').insert(doc, function(error, result){
         if (error) {
           console.log(error);
           process.exit(1);
         }
         /* 
         Once you insert a document, you can then execute a query to get
         that document back. The find function is how you execute a query
         with MongoDB. If you use the Node.js driver directly, you also
         need to chain find together with this .toArray function. You do
         this so that you can work with an array of documents rather than
         iterate through a cursor, which is what you'd have if you did not
         use this .toArray function. Again, you also need to pass a
         callback to the .toArray function. The first argument the callback
         gets is an error if the operation fails. If not, the value of the
         error parameter will be null and the second parameter, docs, will
         contain an array of documents that match the query. So then you
         can iterate through all of the documents and print them to the
         screen. Once again, the return value of this .toArray function
         does not contain the documents. You need to get the array of
         documents from the second parameter to the callback.
         ,*/
         db.collection('movies').find().toArray(function (error, docs){
           if (error) {
             console.log(error);
             process.exit(1);
           }

           console.log('Found docs:');
           docs.forEach(function(doc){
             console.log(JSON.stringify(doc));
           });
           process.exit(0);
         });
       });
     });
   #+END_SRC
   
*** quiz
    Assuming that db is a MongoDB database handle, which of the
    following node.js code examples will print all documents in the
    collection named "movies" where the key "director" is equal to
    "George Lucas"?

    A) 
    #+BEGIN_SRC javascript
    db.collection('movies').find({ director: 'George Lucas' }, function(error, docs) { 
      console.log(docs); 
    });    
    #+END_SRC

    B) 
    #+BEGIN_SRC javascript
    db.collection('movies').find({ director: 'George Lucas' }).toArray(function(error, docs) {
      console.log(docs);
    });
    #+END_SRC

    C) 
    #+BEGIN_SRC javascript
    console.log(db.collection('movies').find({ director: 'George Lucas' }));
    #+END_SRC

    D)
    #+BEGIN_SRC javascript
    console.log(db.collection('movies').find({ director: 'George Lucas' }).toArray());
    #+END_SRC

    
    Answer: B.
** Node.js concurrency and event loop fundamentals
   JavaScript is a language built to run in an event loop. It's called
   an event loop because JavaScript interpreters run in a loop that
   looks something like this:

   while (waitForEvent()) {
     processEvent();
   }

   This loop has numerous interesting semantics. First of all, the
   loop is single threaded, so only one event handler can run at any
   given time. Second, this loop provides an effective way to break up
   long running operations, like network I/O.
   
   Therefore, instead of thinking of JavaScript as an imperative
   programming language like Java or C++, it helps to think of
   JavaScript as running in a loop that executes event handlers that
   can register other event handlers.

   At a high level, this is how the Mongo client dot connect function
   you saw in the Connecting to MongoDB lesson works. Instead of
   blocking the event loop wall, it connects. The Mongo client dot
   connect function registers an event handler that tells Node.js to
   execute your callback function once the network I/O that connects
   to the MongoDB server is done.

   To see the event loop in action, you should asked yourself, what
   would the following program print out?

   #+BEGIN_SRC javascript
   setTimeout(function(){
     console.log('In timeout!');
   }, 0);

   console.log('Not in timeout');   
   #+END_SRC

   If you said not in timeout will print before in timeout, you're
   right. This is because set timeout registers an event handler
   which gets called on the next iteration of the event loop, whereas
   the not in timeout statement gets printed in the current iteration
   of the event loop.
   Typically code that executes in the current iteration of the event
   loop and thus blocks the event loop, like this first log statement,
   is known as synchronous code, whereas code that registers an event
   handler and thus doesn't block the event loop is known as
   asynchronous code.

   In particular, you will notice that every MongoDB operation that
   you'll use in this course uses callbacks, and is thus asynchronous.
   This enables Node.js to be highly concurrent by default. You don't
   have to worry about setting up multiple threads to make sure you're
   not blocking the CPU waiting on a database operation. Many Node.js
   developers find callbacks to be cumbersome. There are numerous MPM
   packages that provide syntactic sugar on top of callbacks, such as
   async and the various promises libraries. However, callbacks are
   handy for determining if your code is doing too much I/O. If you
   have 12 levels of nested callbacks, the problem is probably not the
   callbacks, but that you have a very complex function that's very
   difficult to test.
   
*** quiz
    Which of the following commands will print out all documents in
    the 'test' collection in Node.js?

    1) print(db.test.find());
    
    2) db.collection('test').find().toArray(console.log);

    3) db.collection('test').findOne(console.log);

    4) console.log(db.collection('test').find().toArray());
      

    Answer: 2.
** require() basics
   The require function is Node.js's mechanism for breaking up large
   projects into small, manageable files. The require function lets
   you include functions from external modules and other files in a
   clean and elegant way. You already used the require function once
   before in order to include the MongoDB Node.js driver.

   In this lesson you'll learn how to integrate your own code with the
   require function. In this example you have two files called
   index.js and myfile.js, and the directory called test. The
   index.js file will be the main entry point for your program-- that
   is, you'll run node index.js. The test directory contains two more
   files, index.js and myotherfile.js. The top level index.js file
   will access code from all of these files.

   $ ls -Rl
   .:
   total 4
   -rw-rw-r--   1 gp             gp              0 2017-09-17 20:46 index.js
   -rw-rw-r--   1 gp             gp              0 2017-09-17 20:46 myfile.js
   drwxrwxr-x   2 gp             gp           4096 2017-09-17 20:47 test
   
   test:
   total 0
   -rw-rw-r--   1 gp             gp              0 2017-09-17 20:47 index.js
   -rw-rw-r--   1 gp             gp              0 2017-09-17 20:47 myotherfile.js
   

   The top level index.js file will access code from all of these
   files. Let's take a look at the top level index.js file.

   Now, Node.js uses file level scoping. This means that by default,
   any variable or function declared in a file is not accessible
   outside of that file. Node.js has a global object, but using it is
   almost always a mistake. The require function is the preferred way
   to shar code between files.

   index.js:
   #+BEGIN_SRC javascript
   var fn = require('./myfile.js');
   fn();
   
   var otherFn = require('./test').other;
   otherFn();
   #+END_SRC

   So in this index.js file, you call require on myfile.js and the
   test directory. First let's take a look at what the myfile.js file
   looks like.

   myfile.js:
   #+BEGIN_SRC javascript
   module.exports = function() {
     console.log('Hello from myfile.js');
   };
   #+END_SRC

   
   All myfile.js does is assign a function to this module.exports
   property. Now, you can think of module.exports as the return value
   that somebody gets when they call require on the file. In this
   case, calling require on myfile.js gives you a function that prints
   this hello from myfile.js message.


   Now let's consider what happens when you call require of
   test. Recall that test is a directory, so when you call require on
   a directory, Node.js looks for an index.js file in that directory
   and uses that file. In other words, require of ./test is equivalent
   to require on ./text/index.js.

   Now let's take a look at test/index.js:
   #+BEGIN_SRC javascript
   exports.other = require('./myotherfile');
   #+END_SRC

   Now, this file introduces two subtleties about require. First,
   notice that this file uses exports.other instead of
   module.exports. The exports variable is a convenient shorthand for
   module.exports. This file would do the same thing if you used
   module.exports.other, rather than exports.other. The only
   difference is that you can't directly assign to the exports
   variable. For instance, if you were to use exports rather than
   module.exports in, say, that myfile.js file, Node.js would error
   out. You can only assign properties on the exports variable.

   The other subtlety is that this file calls require on
   myotherfile.js without specifying the test directory. This is
   because require resolves file names relative to the current files
   directory. So in other words, the current working directory when
   you call require on myotherfile within test/index.js is the test
   directory itself. So you don't need to specify test here.

   Finally, let's take a look at the myotherfile.js file that's in the
   test directory.

   test/myotherfile.js:
   #+BEGIN_SRC javascript
   module.exports = function() {
     console.log('Hello from test directory');
   };
   #+END_SRC
   
   This file uses the same module.exports pattern that you saw in
   myfile.js, however it prints a slightly different message through
   the screen. Now that you've taken a look through all the files,
   let's run nodeindex.js. So as you can see, this file prints the
   message from myfile.js, followed by the message from otherfile.js
   from the test directory.

   $ node index.js 
   
   Hello from myfile.js
   Hello from test directory
*** quiz
    Which of the following is not a valid way to export a function
    from a NodeJS file?

    1) module.exports = function() {};

    2) exports.fn = function() {};

    3) exports = function() {};

       
    Answer: 3.

** Using mocha for testing
   Mocha is the most popular testing framework for Node.js. It's also
   useful for testing client side JavaScript. To install Mocha, put a
   dependency on Mocha version 2.2.4 in your package.json and run NPM
   install.

   Let's take a look at what real Mocha tests look like.

   So Mocha uses behavior driven development or BDD for short syntax.
   This means that Mocha uses these /describe/ and /it/ functions in place
   of J unit style suites and tests. BDD style is designed to read
   more like stories than tests. Now, Mocha does not come with its own
   assertion framework, so you can use whichever one you choose.
   There are several alternative assertion frameworks available on
   NPM. But for the purposes of this course, the built-in Node.js
   assert module that you will include here is good enough.
   
   test.js:
  #+BEGIN_SRC javascript
  var assert = require('assert');

  describe('my feature', function() {
    it('works', function() {
      assert.equal('A', 'A');
    });

    it('fails gracefully', function() {
      assert.throws(function() {
        throw 'Error!';
      });
    });
  });

  describe('my other feature', function() {
    it('async', function(done) {
      setTimeout(function() {
        done();
      }, 25);
    });
  });
  #+END_SRC

   Now, in order to run this test.js file, Mocha has an executable
   that's installed in node_modules/.bin.  You can use this
   node_modules/.bin/mocha command to run the test.js file.

   $ node_modules/.bin/mocha test.js

   And as you can see, all these three tests that you saw in this file
   all succeed:
   //////////////////////
   my feature
   [0G    âœ“ works
   [0G    âœ“ fails gracefully
   
   my other feature
   [0G    âœ“ async
   
   
   3 passing (43ms)
   //////////////////////

   The Mocha executable has numerous useful features. For instance,
   the -g flag which is short for --grep allows you to run tests whose
   names match a certain regular expression. For instance, specifying
   -g fail to the Mocha executable will only run this it fails
   gracefully test. Similarly, specifying -g other will run only the
   tests that are under this my other feature describe block, this
   particular describe call.

   /////////////////////
   $ node_modules/.bin/mocha -g "fail" test.js

   
   my feature
   [0G    âœ“ fails gracefully
   
   
   1 passing (11ms)
   /////////////////////

   Mocha also has the ability to use different reporters for test
   output. Reporters control the format that your test results are
   output in. By default, Mocha uses the spec reporter. However, Mocha
   has several other built-in reporters. For instance, the dot
   reporter outputs a very concise format using only dots, which is
   handy for situations when you have thousands of tests.

   ///////////////////
   $ node_modules/.bin/mocha -R dot test.js
   
   â€¤â€¤â€¤
   
   3 passing (36ms)
   ///////////////////
   
   There's also this x unit format, which outputs test results in the
   standard execute in XML format.

   //////////////////
   $ node_modules/.bin/mocha -R xunit test.js

   <testsuite name="Mocha Tests" tests="3" failures="0" errors="0" skipped="0" timestamp="Wed, 20 Sep 2017 15:54:08 GMT" time="0.034">
   <testcase classname="my feature" name="works" time="0.001"/>
   <testcase classname="my feature" name="fails gracefully" time="0.001"/>
   <testcase classname="my other feature" name="async" time="0.029"/>
   </testsuite>
   //////////////////

   Finally, my personal favorite built-in Mocha reported is the nyan
   cat reporter, which outputs a happy little Ascii kitten when all
   your tests succeed.

*** quiz
    Suppose you have the following mocha tests:
    
    #+BEGIN_SRC javascript
    describe('my feature', function() {
      it('works', function() {});
      it('fails gracefully', function() {});
    });
    describe('my other feature', function() {
      it('sorta works', function() {});
    });
    #+END_SRC

    How many tests would run if you ran the above tests with
    ./node_modules/.bin/mocha -g "works"?

    Correct Answer: 2.






   


   
   
   
